#' Fit cox survival to all variants from a standard IMPUTE2 output after genotype imputation
#'
#' Performs survival analysis using Cox proportional hazard models on imputed genetic data from IMPUTE2 output
#'
#' @param impute.file character(1) of IMPUTE2 file 
#' @param sample.file character(1) of sample file affiliated with IMPUTE2 file
#' @param chr numeric(1) denoting chromosome number
#' @param covariate.file data.frame(1) comprising phenotype information, all covariates to be added in the model must be numeric.
#' @param id.column character(1) giving the name of the ID column in covariate.file.
#' @param sample.ids character(1) vector of sample IDs to keep in survival analysis
#' @param time.to.event character(1) of column name in covariate.file that represents the time interval of interest in the analysis
#' @param event character(1) of column name in covariate.file that represents the event of interest to be included in the analysis
#' @param covariates character(1) vector with exact names of columns in covariate.file to include in analysis
#' @param inter.term character(1) string giving the column name of the covariate that will be added to the interaction term with SNP (e.g. \code{term*SNP}). See details.
#' @param print.covs character(1) string of either \code{"only"}, \code{"all"} or \code{"some"}, defining which covariate statistics should be printed to the output. See details.
#' @param out.file character(1) of output file name (do not include extension) 
#' @param chunk.size integer(1) number of variants to process per thread
#' @param maf.filter numeric(1) to filter minor allele frequency (i.e. choosing 0.05 means filtering MAF>0.05). User can set this to `NULL`` if no filtering is preffered. Default is 0.05.
#' @param info.filter numeric(1) to filter imputation INFO score (i.e. choosing 0.7 means filtering info>0.7). Default is `NULL`, no filtering is set.
#' @param flip.dosage logical(1) to flip which allele the dosage was calculated on, default=TRUE
#' @param verbose logical(1) for messages that describe which part of the analysis is currently being run
#' @param clusterObj A cluster object that can be used with the \code{parApply} function. See details.
#' 
#' @details 
#' 
#' @details 
#' 
#' Testing for SNP-covariate interactions:          
#' User can define the column name of the covariate that will be included in the interaction term. 
#' For example, for given covariates \code{a} and \code{b}, where \code{c} is defined as the \code{inter.term} the model will be:
#' \code{~ a + b + c + SNP + c*SNP}.
#' 
#' Printing results of other covariates:       
#' \code{print.covs} argument controls the number of covariates will be printed as output. The function is set to \code{only}
#' by default and will only print the SNP or if an interaction term is given, the results of the interaction 
#' term (e.g. \code{SNP*covariate}). Whereas,  \code{all} will print results (coef, se.coef, p.value etc) of all covariates 
#' included in the model. \code{some} is only applicable if an interaction term is given and will print the results for SNP, 
#' covarite tested for interaction and the interaction term. User should be mindful about using the \code{all} option, as
#' it will likely slow down the analysis and will increase the output file size. 
#'
#' User defined parallelization:  
#' This function uses \code{parApply} from \code{parallel} package to fit models to SNPs in parallel. 
#' User is not required to set any options for the parallelization. 
#' However, advanced users who wish to optimize it, can provide a cluster object generated by \code{makeCluster} 
#' family of functions that suits their need and platform.
#'
#' @return
#' Saves text file directly to disk that contains survival analysis results.
#'  
#' @examples
#' library(gwasurvivr)
#' library(tidyverse)
#' library(magrittr)
#' impute.file <- system.file(package="gwasurvivr","extdata","impute_example.impute2")
#' sample.file <- system.file(package="gwasurvivr",
#'                            "extdata", 
#'                           "impute_example.impute2_sample")
#' chr <- 14
#' covariate.file <- system.file(package="gwasurvivr", 
#'                               "extdata",
#'                              "simulated_pheno.txt")
#' covariate.file <- read_delim(covariate.file, delim=" ")
#' covariate.file <- covariate.file %>% 
#'    mutate(SexFemale=case_when(sex=="female"~1L,
#'                               sex=="male"~0L)) %>%
#'    select(-ID_1)
#' covariate.file %>% head
#' sample.ids <- covariate.file %>%
#'    filter(group=="experimental") %$%
#'    ID_2 
#'impute2CoxSurv(impute.file=impute.file,
#'               sample.file=sample.file,
#'               chr=14,
#'               covariate.file=covariate.file,
#'               id.column="ID_2",
#'               sample.ids=sample.ids,
#'               time.to.event="time",
#'               event="event",
#'               covariates=c("age", "SexFemale", "bmiOVWT"),
#'               inter.term=NULL,
#'               print.covs="only",
#'               out.file="impute_example",
#'               chunk.size=10000,
#'               maf.filter=0.01,
#'               info.filter=0.7,
#'               flip.dosage=TRUE,
#'               verbose=TRUE,
#'               clusterObj=NULL)  
#'  
#' @importFrom survival Surv coxph.fit
#' @importFrom matrixStats rowMeans2 rowVars rowSds
#' @importFrom SummarizedExperiment rowRanges
#' @importFrom utils write.table
#' @importFrom stats pnorm
#' @import parallel
#' @import GWASTools
#'  
#' @export

impute2CoxSurv <- function(impute.file,
                           sample.file,
                           chr,
                           covariate.file,
                           id.column,
                           sample.ids=NULL, 
                           time.to.event, 
                           event,
                           covariates,
                           inter.term=NULL,
                           print.covs="only",
                           out.file,
                           chunk.size=10000,
                           info.filter=0.3,
                           maf.filter=0.05,
                           flip.dosage=TRUE,
                           verbose=TRUE,
                           clusterObj=NULL
                           )
{
    
    ###################################
    #### Phenotype data wrangling #####
    cox.params <- coxPheno(covariate.file, covariates, id.column, inter.term, time.to.event, event, sample.ids, verbose)
    ###################################
    
    ###################################
    ##### Generate cluster obj ########
    # create cluster object depending on user pref or OS type,
    # also create option to input number of cores
    clusterObj <- NULL
    if(!is.null(clusterObj)){
        cl <- clusterObj
    }else if(.Platform$OS.type == "unix") {
        cl <- makeForkCluster(getOption("gwasurvivr.cores", detectCores()))
    } else {
        cl <- makeCluster(getOption("gwasurvivr.cores", detectCores()))
    }
    on.exit(stopCluster(cl), add=TRUE)
    
    
    
    ###################################
    ##### Genotype data wrangling ######
    if (verbose) message("Analysis started on ", format(Sys.time(), "%Y-%m-%d"), " at ", format(Sys.time(), "%H:%M:%S"))
    gdsfile <- tempfile(pattern="", fileext = ".gds")
    snpfile <- tempfile(pattern="", fileext = ".snp.rdata")
    scanfile <- tempfile(pattern="", fileext = ".scan.rdata")
    on.exit(unlink(c(gdsfile, snpfile, scanfile), recursive = TRUE))
    imputedDosageFile(input.files=c(impute.file, sample.file),
                      filename=gdsfile,
                      chromosome=as.numeric(chr),
                      input.type="IMPUTE2",
                      input.dosage=FALSE,
                      file.type="gds",
                      snp.annot.filename = snpfile,
                      scan.annot.filename = scanfile,
                      verbose=FALSE)
    
    # read genotype
    ## need to add if statement about dimensions
    # set default "snp,scan" -- in documentation say it needs to be in this orientation
    gds <- GdsGenotypeReader(gdsfile, genotypeDim="scan,snp")
    # close gds file on exit of the function
    on.exit(close(gds), add=TRUE)
    # read in snp data
    snpAnnot <- getobj(snpfile)
    # read scan
    scanAnnot <- getobj(scanfile)
    # put into GenotypeData coding 
    genoData <- GenotypeData(gds,
                             snpAnnot=snpAnnot,
                             scanAnnot=scanAnnot)
    
    # number of snps in segment
    snp.start <- 1
    snp.end <- nsnp(genoData)
    
    
    
    # get genotypes for certain chunk size
    nsnp.seg <- snp.end - snp.start + 1
    nchunks <- ceiling(nsnp.seg/chunk.size)
    
    
    # set up columns for output
    cols <- c("RSID", "TYPED", "CHR", "POS", "A0","A1", "exp_freq_A1", "SAMP_MAF","INFO")
    write.table( t(cols),
                 paste0(out.file, ".snps_removed"),
                 row.names = FALSE,
                 col.names=FALSE,
                 sep="\t",
                 quote = FALSE,
                 append = FALSE)
    
    snp.df <- data.frame(t(rep(NA, 9)))
    colnames(snp.df) <- cols
    rownames(snp.df) <- NULL
    
    snp.spike <- rbind(rnorm(nrow(cox.params$pheno.file)),
                       rnorm(nrow(cox.params$pheno.file)))
    
    cox.out <- t(apply(snp.spike, 1, survFitInt, cox.params=cox.params, cov.interaction=inter.term, print.covs=print.covs))
    res.cols <- colnames(coxExtract(cox.out, snp.df, cox.params$n.sample, cox.params$n.event, print.covs=print.covs))
    
    write.table( t(res.cols),
                 paste0(out.file, ".coxph"),
                 row.names = FALSE,
                 col.names=FALSE,
                 sep="\t",
                 quote = FALSE,
                 append = FALSE)
    
    
    snp.tot <- list()
    
    
    
    for(i in seq_len(nchunks)){
        
        # set up chunks
        next.chunk <- (i-1)*chunk.size
        next.chunk.start <- snp.start + next.chunk
        snp.chunk <- ifelse(next.chunk.start + chunk.size > snp.end,
                            snp.end - next.chunk.start + 1,
                            chunk.size)
        chunk.idx <- (next.chunk+1):(next.chunk+snp.chunk)
        
        # get genotypes for chunk
        
        genotypes <- getGenotype(genoData,
                                 snp=c(next.chunk.start, snp.chunk),
                                 scan=c(1,-1),
                                 drop=FALSE)
        
        
        snp <- getAnnotation(getSnpAnnotation(genoData))[chunk.idx,] 
        # grab sample file data
        scanAnn <- getAnnotation(getScanAnnotation(genoData))
        
        
        # assign rsIDs (pasted with imputation status) as rows 
        # and sample ID as columns to genotype file
        dimnames(genotypes) <- list(paste(snp$snp, snp$rsID, sep=";"), 
                                    scanAnn$ID_2)
        # Subset genotypes by given samples
        genotypes <- genotypes[,cox.params$ids]
        # flip dosage
        if(flip.dosage) genotypes <- 2 - genotypes
        
        ###################################
        ##### SNP info and filtering #####
        # calculate MAF
        snp$exp_freq_A1 <- round(rowMeans2(genotypes)*0.5,4)
        snp$MAF <- ifelse(snp$exp_freq_A1 > 0.5, 1-snp$exp_freq_A1, snp$exp_freq_A1)
        # calculate info score
        obs.mean <- rowMeans2(genotypes)
        obs.var <- rowVars(genotypes)
        p <- obs.mean/2
        p_all <- 2*p*(1-p)
        info.score <- round(obs.var/p_all,3)
        info.score[info.score>1] <- 1
        snp$info <- info.score
        
        ### Check snps for MAF = 0  ###
        # remove snps with SD less than 1e-4
        # to put this in perspective:
        # a sample size of 100 000 000 with only 1 person being 1 and rest 0,
        # has an SD = 1e-4
        # x <- c(rep(0, 1e8),1)
        # sd(x)
        snp.keep <- rowSds(genotypes) > 1e-4
        if(!all(snp.keep)){
            genotypes <- genotypes[snp.keep,]
            snp.drop <- snp[!snp.keep,]
            snp <- snp[snp.keep,]
        }else{
            snp.drop <- data.frame()
        }
        
        
        
        empty.geno <- tryCatch(
            {
                # Further filter by user defined thresholds
                if(!is.null(maf.filter)){
                    ok.maf <- snp$exp_freq_A1>maf.filter & snp$exp_freq_A1<(1-maf.filter)
                    snp.drop <- base::rbind(snp.drop,snp[!ok.maf,])
                    snp <- snp[ok.maf,]
                    if(all(!ok.maf)) stop("None of the SNPs pass the MAF threshold")
                    genotypes <- genotypes[ok.maf,]
                }
                
                
                if(!is.null(info.filter)){
                    ok.info <- snp$info >= info.filter
                    snp.drop <- base::rbind(snp.drop,snp[!ok.info,])
                    snp <- snp[ok.info,]
                    if(all(!ok.info)) stop("None of the SNPs pass the info threshold")
                    genotypes <- genotypes[ok.info,]
                }
                
                
                snp.cols <- c("snpID","TYPED","RSID","POS","A0","A1","CHR",
                              "exp_freq_A1", "SAMP_MAF","INFO")
                colnames(snp) <- snp.cols
                colnames(snp.drop) <- snp.cols
                snp.ord <- c("RSID", "TYPED", "CHR", "POS", "A0", "A1", "exp_freq_A1", "SAMP_MAF","INFO")
                snp <- snp[, snp.ord]
                snp.drop <- snp.drop[, snp.ord]
                
                write.table(snp.drop, 
                            paste0(out.file, ".snps_removed"),
                            row.names = FALSE,
                            col.names = FALSE,
                            sep="\t",
                            quote = FALSE,
                            append=TRUE)
                
                # fit models in parallel
                if(is.null(inter.term)){
                    if(is.matrix(genotypes)){
                        cox.out <- t(parApply(cl=cl,
                                              X=genotypes, 
                                              MARGIN=1, 
                                              FUN=survFit, 
                                              cox.params=cox.params,
                                              print.covs=print.covs))
                    } else {
                        cox.out <- survFit(genotypes, cox.params=cox.params, print.covs=print.covs)
                    }
                } else if(inter.term %in% covariates){
                    if(is.matrix(genotypes)){
                        cox.out <- t(parApply(cl=cl,
                                              X=genotypes,
                                              MARGIN=1,
                                              FUN=survFitInt, 
                                              cox.params=cox.params, 
                                              cov.interaction=inter.term,
                                              print.covs=print.covs))
                    } else {
                        cox.out <- survFitInt(genotypes,
                                              cox.params=cox.params,
                                              cov.interaction=inter.term, 
                                              print.covs=print.covs)
                    }
                }   
                
                res <- coxExtract(cox.out,
                                  snp,
                                  cox.params$n.sample, 
                                  cox.params$n.event, 
                                  print.covs)
                
                write.table(res, 
                            file=paste0(out.file, ".coxph"),
                            sep="\t",
                            quote=FALSE, 
                            row.names=FALSE,
                            col.names=FALSE,
                            append=TRUE)
                
                snp.tot[["snps_removed"]][i] <- nrow(snp.drop) 
                snp.tot[["snps_analyzed"]][i] <- nrow(res) 
                
            }, 
            error=function(err) err
        )
        
        if(inherits(empty.geno, "error")){
            snp.tot[["snps_removed"]][i] <- nrow(snp.drop)
            snp.tot[["snps_analyzed"]][i] <- NA
            next
        } 
        
        
    }
    if(verbose) message(sum(snp.tot[["snps_removed"]],na.rm=TRUE)," SNPs were removed from the analysis for not meeting\nthe given threshold criteria or for having MAF = 0")
    if(verbose) message("List of removed SNPs are saved to ", paste0(out.file, ".snps_removed"))
    if(verbose) message(sum(snp.tot[["snps_analyzed"]],na.rm=TRUE)," SNPs were included in the analysis")
    if(verbose) message("The Cox model results output was saved to ", paste0(out.file, ".coxph"))
    
    
    
    if (verbose) message("Analysis completed on ", format(Sys.time(), "%Y-%m-%d"), " at ", format(Sys.time(), "%H:%M:%S"))
}




